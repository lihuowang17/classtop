# ClassTop åŒè½¨å¹¶è¡Œæ¶æ„æ–¹æ¡ˆ

## ğŸ“ æ¶æ„æ¦‚è¿°

### ç³»ç»Ÿç»„æˆ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Management Server                      â”‚
â”‚              (ä¼ä¸šçº§ä¸­å¤®ç®¡ç†æœåŠ¡å™¨)                       â”‚
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Core Modules                                     â”‚  â”‚
â”‚  â”‚  - Data Sync (HTTP API)                          â”‚  â”‚
â”‚  â”‚  - Statistics & Analytics                        â”‚  â”‚
â”‚  â”‚  - Multi-client Management                       â”‚  â”‚
â”‚  â”‚  - PostgreSQL Persistence                        â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Extended Modules (New)                          â”‚  â”‚
â”‚  â”‚  - WebSocket Real-time Control                   â”‚  â”‚
â”‚  â”‚  - CCTV Management                               â”‚  â”‚
â”‚  â”‚  - LMS Instance Management                       â”‚  â”‚
â”‚  â”‚  - Remote Command Execution                      â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Web UI (Vue 3 + MDUI 2)                        â”‚  â”‚
â”‚  â”‚  - Dashboard                                      â”‚  â”‚
â”‚  â”‚  - Client Management                             â”‚  â”‚
â”‚  â”‚  - Real-time Control Panel                      â”‚  â”‚
â”‚  â”‚  - LMS Instance Monitor                         â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚                          â”‚
             â”‚ HTTP/WS                  â”‚ HTTP (ç®¡ç†)
             â”‚                          â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ClassTop Client     â”‚   â”‚   LMS Instances      â”‚
â”‚   (Tauri + PyTauri)   â”‚   â”‚   (è½»é‡ç®¡ç†æœåŠ¡)      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ - Local UI            â”‚   â”‚ - WebSocket Server   â”‚
â”‚ - SQLite DB           â”‚   â”‚ - Command Router     â”‚
â”‚ - Course Display      â”‚   â”‚ - Client Registry    â”‚
â”‚ - Data Sync Client    â”‚   â”‚ - SQLite Cache       â”‚
â”‚ - WebSocket Client    â”‚   â”‚ - FastAPI            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚                         â–²
            â”‚ WebSocket (å®æ—¶æ§åˆ¶)     â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### è§’è‰²å®šä½

#### 1. ClassTop Client (å®¢æˆ·ç«¯)
**å®šä½**: ç»ˆç«¯ç”¨æˆ·åº”ç”¨
- æœ¬åœ°è¯¾ç¨‹ç®¡ç†å’Œæ˜¾ç¤º
- åŒæ—¶è¿æ¥ LMS å’Œ Management-Server
- å“åº”å®æ—¶æ§åˆ¶å‘½ä»¤
- å®šæœŸåŒæ­¥æ•°æ®

#### 2. LMS (è½»é‡ç®¡ç†æœåŠ¡ï¼ŒåŸ admin-server)
**å®šä½**: è½»é‡çº§ç°åœºç®¡ç†æœåŠ¡
- éƒ¨ç½²åœ¨æœ¬åœ°ç½‘ç»œ
- ç®¡ç† 10-50 ä¸ªå®¢æˆ·ç«¯
- æä¾›å®æ—¶æ§åˆ¶å’Œç›‘æ§
- ä½å»¶è¿Ÿ WebSocket è¿æ¥
- å¯é€‰ç¦»çº¿è¿è¡Œ

**ä½¿ç”¨åœºæ™¯**:
- å­¦æ ¡æœºæˆ¿ç®¡ç†
- æ•™å®¤è®¾å¤‡æ§åˆ¶
- å®æ—¶ç›‘æ§éœ€æ±‚
- ç½‘ç»œéš”ç¦»ç¯å¢ƒ

#### 3. Management-Server (ä¸­å¤®ç®¡ç†æœåŠ¡å™¨)
**å®šä½**: ä¼ä¸šçº§ä¸­å¤®ç®¡ç†å¹³å°
- éƒ¨ç½²åœ¨äº‘ç«¯æˆ–æ•°æ®ä¸­å¿ƒ
- ç®¡ç†æ•°ç™¾è‡³æ•°åƒä¸ªå®¢æˆ·ç«¯
- é›†ä¸­æ•°æ®å­˜å‚¨å’Œåˆ†æ
- ç®¡ç†å¤šä¸ª LMS å®ä¾‹
- æä¾›ç»Ÿä¸€ç®¡ç†ç•Œé¢

**ä½¿ç”¨åœºæ™¯**:
- å¤šæ ¡åŒºç»Ÿä¸€ç®¡ç†
- æ•°æ®åˆ†æå’ŒæŠ¥è¡¨
- é•¿æœŸæ•°æ®å­˜å‚¨
- è·¨åœ°åŸŸç®¡ç†

## ğŸ”„ é€šä¿¡æ¨¡å¼

### å®¢æˆ·ç«¯ â†” LMS (å®æ—¶æ§åˆ¶)

**åè®®**: WebSocket
**ç”¨é€”**: ä½å»¶è¿Ÿå®æ—¶æ§åˆ¶

```
Client                    LMS
  â”‚                        â”‚
  â”œâ”€â”€â”€â”€ Connect (WS) â”€â”€â”€â”€â”€>â”‚
  â”‚<â”€â”€â”€â”€ Accept â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚                        â”‚
  â”œâ”€â”€â”€â”€ Heartbeat â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
  â”‚<â”€â”€â”€â”€ ACK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚                        â”‚
  â”‚<â”€â”€â”€â”€ Command â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ (è®¾ç½®ä¿®æ”¹/CCTVæ§åˆ¶)
  â”œâ”€â”€â”€â”€ Response â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
  â”‚                        â”‚
```

**æ”¯æŒçš„æ“ä½œ**:
- å®æ—¶è®¾ç½®ä¿®æ”¹
- CCTV å½•åˆ¶/æ¨æµæ§åˆ¶
- çŠ¶æ€æŸ¥è¯¢
- æ—¥å¿—è·å–

### å®¢æˆ·ç«¯ â†” Management-Server (æ•°æ®åŒæ­¥)

**åè®®**: HTTP REST API
**ç”¨é€”**: æ‰¹é‡æ•°æ®åŒæ­¥

```
Client                Management-Server
  â”‚                        â”‚
  â”œâ”€â”€â”€â”€ Register (POST) â”€â”€>â”‚
  â”‚<â”€â”€â”€â”€ UUID â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚                        â”‚
  â”œâ”€â”€â”€â”€ Sync Data (POST) â”€>â”‚ (å®šæœŸï¼Œå¦‚æ¯5åˆ†é’Ÿ)
  â”‚<â”€â”€â”€â”€ Result â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚                        â”‚
```

**åŒæ­¥çš„æ•°æ®**:
- è¯¾ç¨‹å’Œè¯¾ç¨‹è¡¨
- å®¢æˆ·ç«¯çŠ¶æ€
- è®¾ç½®å¿«ç…§
- CCTV é…ç½®

### Management-Server â†” LMS (å®ä¾‹ç®¡ç†)

**åè®®**: HTTP + WebSocket
**ç”¨é€”**: ç®¡ç†å’Œç›‘æ§ LMS å®ä¾‹

```
LMS                   Management-Server
  â”‚                        â”‚
  â”œâ”€â”€â”€â”€ Register (POST) â”€â”€>â”‚ (å¯åŠ¨æ—¶)
  â”‚<â”€â”€â”€â”€ API Key â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚                        â”‚
  â”œâ”€â”€â”€â”€ Heartbeat (WS) â”€â”€â”€>â”‚ (æ¯30ç§’)
  â”‚<â”€â”€â”€â”€ ACK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚                        â”‚
  â”‚<â”€â”€â”€â”€ Query Clients â”€â”€â”€â”€â”€â”¤ (æŸ¥è¯¢LMSç®¡ç†çš„å®¢æˆ·ç«¯)
  â”œâ”€â”€â”€â”€ Client List â”€â”€â”€â”€â”€â”€>â”‚
  â”‚                        â”‚
```

**ç®¡ç†åŠŸèƒ½**:
- LMS å®ä¾‹æ³¨å†Œ
- å¥åº·æ£€æŸ¥
- å®¢æˆ·ç«¯åˆ—è¡¨åŒæ­¥
- é…ç½®åˆ†å‘
- æ—¥å¿—æ”¶é›†

## ğŸ“ è¯¦ç»†è®¾è®¡

### 1. LMS (è½»é‡ç®¡ç†æœåŠ¡) é‡å‘½åå’Œæ”¹è¿›

#### ç›®å½•ç»“æ„è°ƒæ•´

```bash
# å½“å‰
classtop/admin-server/

# æ”¹ä¸º
classtop/lms/  (Light Management Service)
```

#### æ”¹è¿›å†…å®¹

**A. æ·»åŠ æ•°æ®æŒä¹…åŒ–**

```python
# lms/db.py (æ–°å»º)
import sqlite3
from datetime import datetime
from typing import List, Dict, Optional

class LMSDatabase:
    """LMS æœ¬åœ°æ•°æ®åº“"""

    def __init__(self, db_path: str = "lms.db"):
        self.conn = sqlite3.connect(db_path, check_same_thread=False)
        self.init_db()

    def init_db(self):
        """åˆå§‹åŒ–æ•°æ®åº“"""
        cursor = self.conn.cursor()

        # LMS é…ç½®
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS lms_config (
                key TEXT PRIMARY KEY,
                value TEXT,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)

        # å®¢æˆ·ç«¯æ³¨å†Œä¿¡æ¯
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS clients (
                uuid TEXT PRIMARY KEY,
                name TEXT NOT NULL,
                ip_address TEXT,
                last_seen TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                status TEXT DEFAULT 'online',
                metadata TEXT
            )
        """)

        # è¿æ¥å†å²
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS connection_logs (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                client_uuid TEXT NOT NULL,
                event_type TEXT NOT NULL,
                connected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                disconnected_at TIMESTAMP,
                ip_address TEXT
            )
        """)

        # å‘½ä»¤æ‰§è¡Œæ—¥å¿—
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS command_logs (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                client_uuid TEXT NOT NULL,
                command TEXT NOT NULL,
                params TEXT,
                response TEXT,
                success BOOLEAN,
                executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)

        # CCTV äº‹ä»¶æ—¥å¿—
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS cctv_logs (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                client_uuid TEXT NOT NULL,
                event_type TEXT NOT NULL,
                camera_id TEXT,
                details TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)

        self.conn.commit()

    def register_client(self, uuid: str, name: str, ip: str, metadata: dict = None):
        """æ³¨å†Œå®¢æˆ·ç«¯"""
        import json
        cursor = self.conn.cursor()
        cursor.execute("""
            INSERT OR REPLACE INTO clients (uuid, name, ip_address, last_seen, status, metadata)
            VALUES (?, ?, ?, CURRENT_TIMESTAMP, 'online', ?)
        """, (uuid, name, ip, json.dumps(metadata) if metadata else None))
        self.conn.commit()

    def update_client_status(self, uuid: str, status: str):
        """æ›´æ–°å®¢æˆ·ç«¯çŠ¶æ€"""
        cursor = self.conn.cursor()
        cursor.execute("""
            UPDATE clients SET status = ?, last_seen = CURRENT_TIMESTAMP
            WHERE uuid = ?
        """, (status, uuid))
        self.conn.commit()

    def log_command(self, uuid: str, command: str, params: dict, response: dict, success: bool):
        """è®°å½•å‘½ä»¤æ‰§è¡Œ"""
        import json
        cursor = self.conn.cursor()
        cursor.execute("""
            INSERT INTO command_logs (client_uuid, command, params, response, success)
            VALUES (?, ?, ?, ?, ?)
        """, (uuid, command, json.dumps(params), json.dumps(response), success))
        self.conn.commit()

    def get_online_clients(self) -> List[Dict]:
        """è·å–åœ¨çº¿å®¢æˆ·ç«¯"""
        cursor = self.conn.cursor()
        cursor.execute("""
            SELECT uuid, name, ip_address, last_seen, status
            FROM clients
            WHERE status = 'online'
            ORDER BY last_seen DESC
        """)
        columns = [desc[0] for desc in cursor.description]
        return [dict(zip(columns, row)) for row in cursor.fetchall()]

    def get_client_stats(self, uuid: str) -> Dict:
        """è·å–å®¢æˆ·ç«¯ç»Ÿè®¡"""
        cursor = self.conn.cursor()

        # å‘½ä»¤æ‰§è¡Œç»Ÿè®¡
        cursor.execute("""
            SELECT
                COUNT(*) as total_commands,
                SUM(CASE WHEN success = 1 THEN 1 ELSE 0 END) as successful_commands,
                MAX(executed_at) as last_command_time
            FROM command_logs
            WHERE client_uuid = ?
        """, (uuid,))
        result = cursor.fetchone()

        return {
            "total_commands": result[0] or 0,
            "successful_commands": result[1] or 0,
            "last_command_time": result[2]
        }
```

**B. æ³¨å†Œåˆ° Management-Server**

```python
# lms/management_client.py (æ–°å»º)
import requests
import uuid
import socket
import time
import threading
from typing import Optional

class ManagementClient:
    """è¿æ¥åˆ° Management-Server çš„å®¢æˆ·ç«¯"""

    def __init__(self, management_url: str, lms_db):
        self.management_url = management_url
        self.lms_db = lms_db
        self.lms_uuid = self._get_or_create_uuid()
        self.api_key = None
        self.heartbeat_thread = None
        self.is_running = False

    def _get_or_create_uuid(self) -> str:
        """è·å–æˆ–åˆ›å»º LMS UUID"""
        cursor = self.lms_db.conn.cursor()
        cursor.execute("SELECT value FROM lms_config WHERE key = 'lms_uuid'")
        result = cursor.fetchone()

        if result:
            return result[0]
        else:
            lms_uuid = str(uuid.uuid4())
            cursor.execute(
                "INSERT INTO lms_config (key, value) VALUES ('lms_uuid', ?)",
                (lms_uuid,)
            )
            self.lms_db.conn.commit()
            return lms_uuid

    def register(self) -> bool:
        """æ³¨å†Œ LMS åˆ° Management-Server"""
        try:
            data = {
                "lms_uuid": self.lms_uuid,
                "name": f"LMS-{socket.gethostname()}",
                "host": socket.gethostbyname(socket.gethostname()),
                "port": 8000,  # LMS ç«¯å£
                "version": "1.0.0"
            }

            url = f"{self.management_url}/api/lms/register"
            response = requests.post(url, json=data, timeout=10)
            response.raise_for_status()

            result = response.json()
            if result.get("success"):
                self.api_key = result["data"].get("api_key")
                # ä¿å­˜ API Key
                cursor = self.lms_db.conn.cursor()
                cursor.execute(
                    "INSERT OR REPLACE INTO lms_config (key, value) VALUES ('api_key', ?)",
                    (self.api_key,)
                )
                self.lms_db.conn.commit()
                print(f"âœ“ LMS æ³¨å†ŒæˆåŠŸ: {self.lms_uuid}")
                return True

        except Exception as e:
            print(f"âœ— LMS æ³¨å†Œå¤±è´¥: {e}")
            return False

    def start_heartbeat(self):
        """å¯åŠ¨å¿ƒè·³çº¿ç¨‹"""
        if self.is_running:
            return

        self.is_running = True
        self.heartbeat_thread = threading.Thread(target=self._heartbeat_loop, daemon=True)
        self.heartbeat_thread.start()

    def _heartbeat_loop(self):
        """å¿ƒè·³å¾ªç¯"""
        while self.is_running:
            try:
                # è·å–åœ¨çº¿å®¢æˆ·ç«¯åˆ—è¡¨
                clients = self.lms_db.get_online_clients()

                data = {
                    "lms_uuid": self.lms_uuid,
                    "client_count": len(clients),
                    "clients": [
                        {
                            "uuid": c["uuid"],
                            "name": c["name"],
                            "status": c["status"]
                        }
                        for c in clients
                    ]
                }

                headers = {"Authorization": f"Bearer {self.api_key}"}
                url = f"{self.management_url}/api/lms/heartbeat"
                response = requests.post(url, json=data, headers=headers, timeout=5)

                if response.status_code == 200:
                    print(f"âœ“ å¿ƒè·³æˆåŠŸ: {len(clients)} ä¸ªåœ¨çº¿å®¢æˆ·ç«¯")
                else:
                    print(f"âœ— å¿ƒè·³å¤±è´¥: {response.status_code}")

            except Exception as e:
                print(f"âœ— å¿ƒè·³å¼‚å¸¸: {e}")

            time.sleep(30)  # æ¯30ç§’ä¸€æ¬¡

    def stop_heartbeat(self):
        """åœæ­¢å¿ƒè·³"""
        self.is_running = False
        if self.heartbeat_thread:
            self.heartbeat_thread.join(timeout=5)
```

**C. æ›´æ–° main.py é›†æˆ**

```python
# lms/main.py
from fastapi import FastAPI, WebSocket, WebSocketDisconnect
from websocket_manager import manager
from db import LMSDatabase
from management_client import ManagementClient
import os

app = FastAPI(title="LMS - Light Management Service")

# åˆå§‹åŒ–æ•°æ®åº“
lms_db = LMSDatabase()

# åˆå§‹åŒ– Management-Server å®¢æˆ·ç«¯
management_url = os.getenv("MANAGEMENT_SERVER_URL", "http://localhost:8765")
management_client = ManagementClient(management_url, lms_db) if management_url else None

@app.on_event("startup")
async def startup():
    """å¯åŠ¨æ—¶æ³¨å†Œåˆ° Management-Server"""
    if management_client:
        if management_client.register():
            management_client.start_heartbeat()

@app.on_event("shutdown")
async def shutdown():
    """å…³é—­æ—¶åœæ­¢å¿ƒè·³"""
    if management_client:
        management_client.stop_heartbeat()

@app.websocket("/ws/{client_uuid}")
async def websocket_endpoint(websocket: WebSocket, client_uuid: str):
    await manager.connect(client_uuid, websocket)

    # è®°å½•è¿æ¥
    client_info = await websocket.receive_json()
    lms_db.register_client(
        client_uuid,
        client_info.get("name", "Unknown"),
        websocket.client.host
    )

    try:
        while True:
            data = await websocket.receive_json()

            # å¤„ç†æ¶ˆæ¯
            if data.get("type") == "heartbeat":
                await websocket.send_json({"type": "heartbeat_ack"})
                lms_db.update_client_status(client_uuid, "online")

            elif data.get("type") == "response":
                # è®°å½•å‘½ä»¤å“åº”
                request_id = data.get("request_id")
                lms_db.log_command(
                    client_uuid,
                    data.get("command", ""),
                    {},
                    data.get("data", {}),
                    data.get("success", False)
                )

    except WebSocketDisconnect:
        manager.disconnect(client_uuid)
        lms_db.update_client_status(client_uuid, "offline")

# ... å…¶ä»–è·¯ç”±ä¿æŒä¸å˜ ...
```

### 2. Management-Server åŠŸèƒ½æ‰©å±•

#### A. æ·»åŠ  LMS å®ä¾‹ç®¡ç†

**æ•°æ®åº“ Schema æ›´æ–°**

```sql
-- migrations/003_add_lms_support.sql

-- LMS å®ä¾‹è¡¨
CREATE TABLE IF NOT EXISTS lms_instances (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    lms_uuid UUID NOT NULL UNIQUE,
    name VARCHAR(255) NOT NULL,
    host VARCHAR(255),
    port INTEGER DEFAULT 8000,
    api_key VARCHAR(255) NOT NULL,
    status VARCHAR(50) DEFAULT 'offline',  -- online, offline, error
    last_heartbeat TIMESTAMPTZ,
    client_count INTEGER DEFAULT 0,
    version VARCHAR(50),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- LMS ç®¡ç†çš„å®¢æˆ·ç«¯å…³ç³»è¡¨
CREATE TABLE IF NOT EXISTS lms_client_mapping (
    id SERIAL PRIMARY KEY,
    lms_id UUID NOT NULL REFERENCES lms_instances(id) ON DELETE CASCADE,
    client_id UUID NOT NULL REFERENCES clients(id) ON DELETE CASCADE,
    connected_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(lms_id, client_id)
);

-- LMS å¿ƒè·³æ—¥å¿—
CREATE TABLE IF NOT EXISTS lms_heartbeats (
    id SERIAL PRIMARY KEY,
    lms_id UUID NOT NULL REFERENCES lms_instances(id) ON DELETE CASCADE,
    client_count INTEGER,
    received_at TIMESTAMPTZ DEFAULT NOW()
);

-- ä¸º clients è¡¨æ·»åŠ  lms_id å­—æ®µ
ALTER TABLE clients ADD COLUMN IF NOT EXISTS lms_id UUID REFERENCES lms_instances(id);

-- ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_lms_status ON lms_instances(status);
CREATE INDEX IF NOT EXISTS idx_lms_last_heartbeat ON lms_instances(last_heartbeat);
CREATE INDEX IF NOT EXISTS idx_lms_client_mapping_lms ON lms_client_mapping(lms_id);
CREATE INDEX IF NOT EXISTS idx_clients_lms_id ON clients(lms_id);
```

**Rust æ•°æ®æ¨¡å‹**

```rust
// src/models.rs

use serde::{Deserialize, Serialize};
use utoipa::ToSchema;
use uuid::Uuid;
use chrono::{DateTime, Utc};

#[derive(Debug, Serialize, Deserialize, ToSchema)]
pub struct LMSInstance {
    pub id: Uuid,
    pub lms_uuid: Uuid,
    pub name: String,
    pub host: Option<String>,
    pub port: i32,
    pub status: String,
    pub last_heartbeat: Option<DateTime<Utc>>,
    pub client_count: i32,
    pub version: Option<String>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Debug, Deserialize, ToSchema)]
pub struct RegisterLMSRequest {
    pub lms_uuid: Uuid,
    pub name: String,
    pub host: String,
    pub port: i32,
    pub version: String,
}

#[derive(Debug, Serialize, ToSchema)]
pub struct RegisterLMSResponse {
    pub lms_id: Uuid,
    pub api_key: String,
}

#[derive(Debug, Deserialize, ToSchema)]
pub struct LMSHeartbeatRequest {
    pub lms_uuid: Uuid,
    pub client_count: i32,
    pub clients: Vec<LMSClientInfo>,
}

#[derive(Debug, Deserialize, Serialize, ToSchema)]
pub struct LMSClientInfo {
    pub uuid: Uuid,
    pub name: String,
    pub status: String,
}
```

**API Handler**

```rust
// src/handlers/lms.rs (æ–°å»º)

use actix_web::{web, HttpResponse};
use sqlx::PgPool;
use uuid::Uuid;
use crate::models::*;
use crate::db::repository::Repository;
use crate::error::{AppError, AppResult};

/// æ³¨å†Œ LMS å®ä¾‹
#[utoipa::path(
    post,
    path = "/api/lms/register",
    request_body = RegisterLMSRequest,
    responses(
        (status = 200, description = "LMS registered successfully", body = ApiResponse<RegisterLMSResponse>),
        (status = 400, description = "Bad request"),
        (status = 500, description = "Internal server error")
    ),
    tag = "LMS Management"
)]
pub async fn register_lms(
    pool: web::Data<PgPool>,
    req: web::Json<RegisterLMSRequest>,
) -> AppResult<HttpResponse> {
    let repo = Repository::new(pool.get_ref().clone());

    // ç”Ÿæˆ API Key
    let api_key = generate_api_key();

    // æ³¨å†Œ LMS
    let lms_id = repo.register_lms(
        req.lms_uuid,
        &req.name,
        &req.host,
        req.port,
        &api_key,
        &req.version,
    ).await?;

    let response = RegisterLMSResponse {
        lms_id,
        api_key,
    };

    Ok(HttpResponse::Ok().json(ApiResponse::success(response)))
}

/// LMS å¿ƒè·³
#[utoipa::path(
    post,
    path = "/api/lms/heartbeat",
    request_body = LMSHeartbeatRequest,
    responses(
        (status = 200, description = "Heartbeat received"),
        (status = 401, description = "Unauthorized"),
        (status = 404, description = "LMS not found")
    ),
    tag = "LMS Management",
    security(("api_key" = []))
)]
pub async fn lms_heartbeat(
    pool: web::Data<PgPool>,
    req: web::Json<LMSHeartbeatRequest>,
    // TODO: æ·»åŠ  API Key éªŒè¯ä¸­é—´ä»¶
) -> AppResult<HttpResponse> {
    let repo = Repository::new(pool.get_ref().clone());

    // æ›´æ–° LMS çŠ¶æ€
    repo.update_lms_heartbeat(
        req.lms_uuid,
        req.client_count,
        &req.clients,
    ).await?;

    Ok(HttpResponse::Ok().json(ApiResponse::success("Heartbeat received")))
}

/// è·å–æ‰€æœ‰ LMS å®ä¾‹
#[utoipa::path(
    get,
    path = "/api/lms",
    responses(
        (status = 200, description = "List of LMS instances", body = ApiResponse<Vec<LMSInstance>>)
    ),
    tag = "LMS Management"
)]
pub async fn list_lms(
    pool: web::Data<PgPool>,
) -> AppResult<HttpResponse> {
    let repo = Repository::new(pool.get_ref().clone());
    let instances = repo.get_all_lms_instances().await?;
    Ok(HttpResponse::Ok().json(ApiResponse::success(instances)))
}

/// è·å–å•ä¸ª LMS å®ä¾‹è¯¦æƒ…
#[utoipa::path(
    get,
    path = "/api/lms/{lms_id}",
    params(
        ("lms_id" = Uuid, Path, description = "LMS instance ID")
    ),
    responses(
        (status = 200, description = "LMS instance details", body = ApiResponse<LMSInstance>),
        (status = 404, description = "LMS not found")
    ),
    tag = "LMS Management"
)]
pub async fn get_lms(
    pool: web::Data<PgPool>,
    lms_id: web::Path<Uuid>,
) -> AppResult<HttpResponse> {
    let repo = Repository::new(pool.get_ref().clone());
    let instance = repo.get_lms_by_id(*lms_id).await?;
    Ok(HttpResponse::Ok().json(ApiResponse::success(instance)))
}

/// è·å– LMS ç®¡ç†çš„å®¢æˆ·ç«¯åˆ—è¡¨
#[utoipa::path(
    get,
    path = "/api/lms/{lms_id}/clients",
    params(
        ("lms_id" = Uuid, Path, description = "LMS instance ID")
    ),
    responses(
        (status = 200, description = "List of clients managed by this LMS", body = ApiResponse<Vec<Client>>)
    ),
    tag = "LMS Management"
)]
pub async fn get_lms_clients(
    pool: web::Data<PgPool>,
    lms_id: web::Path<Uuid>,
) -> AppResult<HttpResponse> {
    let repo = Repository::new(pool.get_ref().clone());
    let clients = repo.get_clients_by_lms(*lms_id).await?;
    Ok(HttpResponse::Ok().json(ApiResponse::success(clients)))
}

/// åˆ é™¤ LMS å®ä¾‹
#[utoipa::path(
    delete,
    path = "/api/lms/{lms_id}",
    params(
        ("lms_id" = Uuid, Path, description = "LMS instance ID")
    ),
    responses(
        (status = 200, description = "LMS deleted successfully"),
        (status = 404, description = "LMS not found")
    ),
    tag = "LMS Management"
)]
pub async fn delete_lms(
    pool: web::Data<PgPool>,
    lms_id: web::Path<Uuid>,
) -> AppResult<HttpResponse> {
    let repo = Repository::new(pool.get_ref().clone());
    repo.delete_lms(*lms_id).await?;
    Ok(HttpResponse::Ok().json(ApiResponse::success("LMS deleted")))
}

// è¾…åŠ©å‡½æ•°
fn generate_api_key() -> String {
    use rand::Rng;
    const CHARSET: &[u8] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    let mut rng = rand::thread_rng();
    (0..32)
        .map(|_| {
            let idx = rng.gen_range(0..CHARSET.len());
            CHARSET[idx] as char
        })
        .collect()
}
```

**æ•°æ®åº“æ“ä½œ (Repository)**

```rust
// src/db.rs - æ·»åŠ åˆ° Repository impl

impl Repository {
    pub async fn register_lms(
        &self,
        lms_uuid: Uuid,
        name: &str,
        host: &str,
        port: i32,
        api_key: &str,
        version: &str,
    ) -> AppResult<Uuid> {
        let row = sqlx::query!(
            r#"
            INSERT INTO lms_instances (lms_uuid, name, host, port, api_key, version, status)
            VALUES ($1, $2, $3, $4, $5, $6, 'online')
            RETURNING id
            "#,
            lms_uuid,
            name,
            host,
            port,
            api_key,
            version
        )
        .fetch_one(&self.pool)
        .await
        .map_err(|e| AppError::Database(e.to_string()))?;

        Ok(row.id)
    }

    pub async fn update_lms_heartbeat(
        &self,
        lms_uuid: Uuid,
        client_count: i32,
        clients: &[LMSClientInfo],
    ) -> AppResult<()> {
        // æ›´æ–° LMS çŠ¶æ€
        sqlx::query!(
            r#"
            UPDATE lms_instances
            SET last_heartbeat = NOW(),
                client_count = $2,
                status = 'online',
                updated_at = NOW()
            WHERE lms_uuid = $1
            "#,
            lms_uuid,
            client_count
        )
        .execute(&self.pool)
        .await
        .map_err(|e| AppError::Database(e.to_string()))?;

        // è®°å½•å¿ƒè·³æ—¥å¿—
        let lms_id = self.get_lms_id_by_uuid(lms_uuid).await?;
        sqlx::query!(
            r#"
            INSERT INTO lms_heartbeats (lms_id, client_count)
            VALUES ($1, $2)
            "#,
            lms_id,
            client_count
        )
        .execute(&self.pool)
        .await
        .map_err(|e| AppError::Database(e.to_string()))?;

        // æ›´æ–°å®¢æˆ·ç«¯ä¸ LMS çš„æ˜ å°„å…³ç³»
        for client in clients {
            sqlx::query!(
                r#"
                INSERT INTO lms_client_mapping (lms_id, client_id)
                VALUES ($1, $2)
                ON CONFLICT (lms_id, client_id) DO NOTHING
                "#,
                lms_id,
                client.uuid
            )
            .execute(&self.pool)
            .await
            .ok(); // å¿½ç•¥é”™è¯¯ï¼Œå®¢æˆ·ç«¯å¯èƒ½æœªæ³¨å†Œåˆ° Management-Server
        }

        Ok(())
    }

    pub async fn get_all_lms_instances(&self) -> AppResult<Vec<LMSInstance>> {
        let instances = sqlx::query_as!(
            LMSInstance,
            r#"
            SELECT id, lms_uuid, name, host, port, status,
                   last_heartbeat, client_count, version,
                   created_at, updated_at
            FROM lms_instances
            ORDER BY created_at DESC
            "#
        )
        .fetch_all(&self.pool)
        .await
        .map_err(|e| AppError::Database(e.to_string()))?;

        Ok(instances)
    }

    pub async fn get_lms_by_id(&self, lms_id: Uuid) -> AppResult<LMSInstance> {
        let instance = sqlx::query_as!(
            LMSInstance,
            r#"
            SELECT id, lms_uuid, name, host, port, status,
                   last_heartbeat, client_count, version,
                   created_at, updated_at
            FROM lms_instances
            WHERE id = $1
            "#,
            lms_id
        )
        .fetch_optional(&self.pool)
        .await
        .map_err(|e| AppError::Database(e.to_string()))?
        .ok_or(AppError::NotFound("LMS instance not found".to_string()))?;

        Ok(instance)
    }

    pub async fn get_clients_by_lms(&self, lms_id: Uuid) -> AppResult<Vec<Client>> {
        let clients = sqlx::query_as!(
            Client,
            r#"
            SELECT c.id, c.uuid, c.name, c.api_url, c.status,
                   c.last_sync, c.created_at
            FROM clients c
            INNER JOIN lms_client_mapping lcm ON c.id = lcm.client_id
            WHERE lcm.lms_id = $1
            ORDER BY c.name
            "#,
            lms_id
        )
        .fetch_all(&self.pool)
        .await
        .map_err(|e| AppError::Database(e.to_string()))?;

        Ok(clients)
    }

    pub async fn delete_lms(&self, lms_id: Uuid) -> AppResult<()> {
        sqlx::query!(
            "DELETE FROM lms_instances WHERE id = $1",
            lms_id
        )
        .execute(&self.pool)
        .await
        .map_err(|e| AppError::Database(e.to_string()))?;

        Ok(())
    }

    async fn get_lms_id_by_uuid(&self, lms_uuid: Uuid) -> AppResult<Uuid> {
        let row = sqlx::query!(
            "SELECT id FROM lms_instances WHERE lms_uuid = $1",
            lms_uuid
        )
        .fetch_optional(&self.pool)
        .await
        .map_err(|e| AppError::Database(e.to_string()))?
        .ok_or(AppError::NotFound("LMS not found".to_string()))?;

        Ok(row.id)
    }
}
```

#### B. æ·»åŠ  WebSocket å®æ—¶æ§åˆ¶åŠŸèƒ½

**WebSocket Handler**

```rust
// src/handlers/websocket.rs (æ–°å»º)

use actix::{Actor, StreamHandler, Handler, Message as ActixMessage, AsyncContext};
use actix_web::{web, HttpRequest, HttpResponse, Error};
use actix_web_actors::ws;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use uuid::Uuid;

/// WebSocket æ¶ˆæ¯ç±»å‹
#[derive(Debug, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum WSMessage {
    #[serde(rename = "command")]
    Command {
        target_client: Uuid,
        request_id: String,
        command: String,
        params: serde_json::Value,
    },
    #[serde(rename = "response")]
    Response {
        request_id: String,
        success: bool,
        data: serde_json::Value,
    },
    #[serde(rename = "heartbeat")]
    Heartbeat,
    #[serde(rename = "register")]
    Register {
        client_uuid: Uuid,
        client_type: String, // "client" æˆ– "lms"
    },
}

/// WebSocket è¿æ¥ç®¡ç†å™¨
pub struct WSConnectionManager {
    // client_uuid -> WebSocket Actor Address
    connections: Arc<Mutex<HashMap<Uuid, actix::Addr<WSConnection>>>>,
}

impl WSConnectionManager {
    pub fn new() -> Self {
        Self {
            connections: Arc::new(Mutex::new(HashMap::new())),
        }
    }

    pub fn register(&self, uuid: Uuid, addr: actix::Addr<WSConnection>) {
        self.connections.lock().unwrap().insert(uuid, addr);
    }

    pub fn unregister(&self, uuid: &Uuid) {
        self.connections.lock().unwrap().remove(uuid);
    }

    pub fn send_to_client(&self, uuid: Uuid, msg: WSMessage) -> Result<(), String> {
        if let Some(addr) = self.connections.lock().unwrap().get(&uuid) {
            addr.do_send(SendWSMessage(msg));
            Ok(())
        } else {
            Err(format!("Client {} not connected", uuid))
        }
    }

    pub fn get_online_count(&self) -> usize {
        self.connections.lock().unwrap().len()
    }
}

/// WebSocket Actor
pub struct WSConnection {
    uuid: Option<Uuid>,
    client_type: Option<String>,
    manager: web::Data<WSConnectionManager>,
}

impl Actor for WSConnection {
    type Context = ws::WebsocketContext<Self>;

    fn started(&mut self, ctx: &mut Self::Context) {
        println!("WebSocket connection started");
    }

    fn stopped(&mut self, _: &mut Self::Context) {
        if let Some(uuid) = self.uuid {
            self.manager.unregister(&uuid);
            println!("WebSocket disconnected: {}", uuid);
        }
    }
}

/// å¤„ç† WebSocket æ¶ˆæ¯
impl StreamHandler<Result<ws::Message, ws::ProtocolError>> for WSConnection {
    fn handle(&mut self, msg: Result<ws::Message, ws::ProtocolError>, ctx: &mut Self::Context) {
        match msg {
            Ok(ws::Message::Ping(msg)) => ctx.pong(&msg),
            Ok(ws::Message::Pong(_)) => {}
            Ok(ws::Message::Text(text)) => {
                // è§£ææ¶ˆæ¯
                match serde_json::from_str::<WSMessage>(&text) {
                    Ok(ws_msg) => self.handle_ws_message(ws_msg, ctx),
                    Err(e) => eprintln!("Failed to parse WebSocket message: {}", e),
                }
            }
            Ok(ws::Message::Binary(_)) => {
                eprintln!("Binary messages not supported");
            }
            Ok(ws::Message::Close(reason)) => {
                ctx.close(reason);
                ctx.stop();
            }
            _ => (),
        }
    }
}

impl WSConnection {
    fn handle_ws_message(&mut self, msg: WSMessage, ctx: &mut ws::WebsocketContext<Self>) {
        match msg {
            WSMessage::Register { client_uuid, client_type } => {
                self.uuid = Some(client_uuid);
                self.client_type = Some(client_type.clone());
                self.manager.register(client_uuid, ctx.address());

                println!("Client registered: {} (type: {})", client_uuid, client_type);

                // å‘é€ç¡®è®¤
                let response = WSMessage::Response {
                    request_id: "register".to_string(),
                    success: true,
                    data: serde_json::json!({"message": "Registered successfully"}),
                };
                ctx.text(serde_json::to_string(&response).unwrap());
            }
            WSMessage::Heartbeat => {
                let response = WSMessage::Response {
                    request_id: "heartbeat".to_string(),
                    success: true,
                    data: serde_json::json!({"timestamp": chrono::Utc::now()}),
                };
                ctx.text(serde_json::to_string(&response).unwrap());
            }
            WSMessage::Response { .. } => {
                // å“åº”æ¶ˆæ¯ä¼šè¢«è·¯ç”±åˆ°ç­‰å¾…çš„è¯·æ±‚
                // è¿™é‡Œå¯ä»¥å®ç°è¯·æ±‚-å“åº”æ˜ å°„é€»è¾‘
                if let Ok(json) = serde_json::to_string(&msg) {
                    ctx.text(json);
                }
            }
            _ => {}
        }
    }
}

/// å†…éƒ¨æ¶ˆæ¯ï¼šå‘é€ WebSocket æ¶ˆæ¯
#[derive(ActixMessage)]
#[rtype(result = "()")]
struct SendWSMessage(WSMessage);

impl Handler<SendWSMessage> for WSConnection {
    type Result = ();

    fn handle(&mut self, msg: SendWSMessage, ctx: &mut Self::Context) {
        if let Ok(json) = serde_json::to_string(&msg.0) {
            ctx.text(json);
        }
    }
}

/// WebSocket ç«¯ç‚¹
pub async fn ws_endpoint(
    req: HttpRequest,
    stream: web::Payload,
    manager: web::Data<WSConnectionManager>,
) -> Result<HttpResponse, Error> {
    ws::start(
        WSConnection {
            uuid: None,
            client_type: None,
            manager,
        },
        &req,
        stream,
    )
}

/// HTTP APIï¼šå‘å®¢æˆ·ç«¯å‘é€å‘½ä»¤
#[utoipa::path(
    post,
    path = "/api/control/command",
    request_body = SendCommandRequest,
    responses(
        (status = 200, description = "Command sent successfully"),
        (status = 404, description = "Client not connected")
    ),
    tag = "Real-time Control"
)]
pub async fn send_command(
    manager: web::Data<WSConnectionManager>,
    req: web::Json<SendCommandRequest>,
) -> Result<HttpResponse, Error> {
    let msg = WSMessage::Command {
        target_client: req.target_client,
        request_id: req.request_id.clone(),
        command: req.command.clone(),
        params: req.params.clone(),
    };

    match manager.send_to_client(req.target_client, msg) {
        Ok(_) => Ok(HttpResponse::Ok().json(serde_json::json!({
            "success": true,
            "message": "Command sent"
        }))),
        Err(e) => Ok(HttpResponse::NotFound().json(serde_json::json!({
            "success": false,
            "error": e
        }))),
    }
}

#[derive(Debug, Deserialize)]
pub struct SendCommandRequest {
    pub target_client: Uuid,
    pub request_id: String,
    pub command: String,
    pub params: serde_json::Value,
}
```

**è·¯ç”±æ³¨å†Œ**

```rust
// src/main.rs - æ·»åŠ  WebSocket è·¯ç”±

use actix_web::{web, App, HttpServer};
mod handlers;
use handlers::websocket::{ws_endpoint, send_command, WSConnectionManager};

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    // ... åˆå§‹åŒ–æ•°æ®åº“è¿æ¥æ±  ...

    // åˆ›å»º WebSocket è¿æ¥ç®¡ç†å™¨
    let ws_manager = web::Data::new(WSConnectionManager::new());

    HttpServer::new(move || {
        App::new()
            .app_data(pool.clone())
            .app_data(ws_manager.clone())
            // WebSocket è·¯ç”±
            .route("/ws", web::get().to(ws_endpoint))
            .route("/api/control/command", web::post().to(send_command))
            // ... å…¶ä»–è·¯ç”± ...
    })
    .bind(("0.0.0.0", 8765))?
    .run()
    .await
}
```

#### C. æ·»åŠ  CCTV ç®¡ç†åŠŸèƒ½

**æ•°æ®æ¨¡å‹**

```rust
// src/models.rs - æ·»åŠ  CCTV ç›¸å…³æ¨¡å‹

#[derive(Debug, Serialize, Deserialize, ToSchema)]
pub struct CCTVConfig {
    pub id: Uuid,
    pub client_id: Uuid,
    pub camera_id: String,
    pub camera_name: String,
    pub rtsp_url: Option<String>,
    pub recording_enabled: bool,
    pub streaming_enabled: bool,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Debug, Deserialize, ToSchema)]
pub struct UpdateCCTVRequest {
    pub camera_name: Option<String>,
    pub rtsp_url: Option<String>,
    pub recording_enabled: Option<bool>,
    pub streaming_enabled: Option<bool>,
}

#[derive(Debug, Serialize, ToSchema)]
pub struct CCTVStatus {
    pub camera_id: String,
    pub is_recording: bool,
    pub is_streaming: bool,
    pub last_frame_time: Option<DateTime<Utc>>,
}
```

**æ•°æ®åº“è¿ç§»**

```sql
-- migrations/004_add_cctv_support.sql

CREATE TABLE IF NOT EXISTS cctv_configs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    client_id UUID NOT NULL REFERENCES clients(id) ON DELETE CASCADE,
    camera_id VARCHAR(100) NOT NULL,
    camera_name VARCHAR(255) NOT NULL,
    rtsp_url TEXT,
    recording_enabled BOOLEAN DEFAULT FALSE,
    streaming_enabled BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(client_id, camera_id)
);

CREATE TABLE IF NOT EXISTS cctv_events (
    id SERIAL PRIMARY KEY,
    camera_config_id UUID NOT NULL REFERENCES cctv_configs(id) ON DELETE CASCADE,
    event_type VARCHAR(50) NOT NULL, -- start_recording, stop_recording, start_stream, stop_stream, error
    details JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_cctv_configs_client ON cctv_configs(client_id);
CREATE INDEX IF NOT EXISTS idx_cctv_events_camera ON cctv_events(camera_config_id);
CREATE INDEX IF NOT EXISTS idx_cctv_events_time ON cctv_events(created_at);
```

### 3. å®¢æˆ·ç«¯æ›´æ–°

#### A. åŒè¿æ¥æ”¯æŒ

**é…ç½®æ›´æ–°**

```python
# src-tauri/python/tauri_app/settings_manager.py

class SettingsManager:
    """è®¾ç½®ç®¡ç†å™¨"""

    DEFAULT_SETTINGS = {
        # ... ç°æœ‰è®¾ç½® ...

        # LMS è¿æ¥é…ç½®
        "lms_enabled": "true",
        "lms_url": "ws://localhost:8000/ws",
        "lms_auto_reconnect": "true",

        # Management-Server è¿æ¥é…ç½®
        "management_server_enabled": "true",
        "management_server_url": "http://localhost:8765",
        "management_ws_url": "ws://localhost:8765/ws",
        "sync_interval": "300",  # 5åˆ†é’Ÿ

        # åŒè¿æ¥æ¨¡å¼
        "dual_connection_mode": "both",  # lms_only, management_only, both
    }
```

**è¿æ¥ç®¡ç†å™¨**

```python
# src-tauri/python/tauri_app/connection_manager.py (æ–°å»º)

import asyncio
import websockets
import json
from typing import Optional, Callable
from datetime import datetime

class LMSConnection:
    """LMS WebSocket è¿æ¥"""

    def __init__(self, url: str, client_uuid: str, on_command: Callable):
        self.url = url
        self.client_uuid = client_uuid
        self.on_command = on_command
        self.websocket = None
        self.is_connected = False
        self.reconnect_task = None

    async def connect(self):
        """è¿æ¥åˆ° LMS"""
        try:
            self.websocket = await websockets.connect(self.url)
            self.is_connected = True

            # å‘é€æ³¨å†Œæ¶ˆæ¯
            await self.websocket.send(json.dumps({
                "type": "register",
                "client_uuid": self.client_uuid,
                "client_type": "client"
            }))

            # å¯åŠ¨æ¶ˆæ¯å¤„ç†å¾ªç¯
            asyncio.create_task(self._message_loop())

            print(f"âœ“ Connected to LMS: {self.url}")
            return True

        except Exception as e:
            print(f"âœ— Failed to connect to LMS: {e}")
            self.is_connected = False
            return False

    async def _message_loop(self):
        """æ¶ˆæ¯å¤„ç†å¾ªç¯"""
        try:
            async for message in self.websocket:
                data = json.loads(message)
                await self._handle_message(data)
        except Exception as e:
            print(f"âœ— LMS message loop error: {e}")
            self.is_connected = False
            # è§¦å‘é‡è¿
            asyncio.create_task(self.reconnect())

    async def _handle_message(self, data: dict):
        """å¤„ç†æ”¶åˆ°çš„æ¶ˆæ¯"""
        msg_type = data.get("type")

        if msg_type == "command":
            # æ‰§è¡Œå‘½ä»¤
            request_id = data.get("request_id")
            command = data.get("command")
            params = data.get("params", {})

            try:
                result = await self.on_command(command, params)
                response = {
                    "type": "response",
                    "request_id": request_id,
                    "success": True,
                    "data": result
                }
            except Exception as e:
                response = {
                    "type": "response",
                    "request_id": request_id,
                    "success": False,
                    "data": {"error": str(e)}
                }

            await self.websocket.send(json.dumps(response))

        elif msg_type == "response":
            # å“åº”æ¶ˆæ¯
            print(f"Received response: {data}")

    async def send_heartbeat(self):
        """å‘é€å¿ƒè·³"""
        if self.is_connected and self.websocket:
            try:
                await self.websocket.send(json.dumps({"type": "heartbeat"}))
            except Exception as e:
                print(f"âœ— Heartbeat failed: {e}")
                self.is_connected = False

    async def reconnect(self):
        """é‡è¿"""
        await asyncio.sleep(5)  # 5ç§’åé‡è¯•
        await self.connect()

    async def close(self):
        """å…³é—­è¿æ¥"""
        self.is_connected = False
        if self.websocket:
            await self.websocket.close()


class ManagementServerConnection:
    """Management-Server HTTP è¿æ¥"""

    def __init__(self, base_url: str, ws_url: str, client_uuid: str):
        self.base_url = base_url
        self.ws_url = ws_url
        self.client_uuid = client_uuid
        self.ws_connection = None
        self.sync_task = None

    async def register(self) -> bool:
        """æ³¨å†Œå®¢æˆ·ç«¯"""
        import aiohttp

        try:
            async with aiohttp.ClientSession() as session:
                data = {
                    "uuid": self.client_uuid,
                    "name": f"ClassTop-{self.client_uuid[:8]}",
                    "api_url": "http://localhost:1420"  # å®¢æˆ·ç«¯æœ¬åœ° API
                }

                async with session.post(
                    f"{self.base_url}/api/clients/register",
                    json=data
                ) as resp:
                    if resp.status == 200:
                        print(f"âœ“ Registered to Management-Server")
                        return True
                    else:
                        print(f"âœ— Registration failed: {resp.status}")
                        return False

        except Exception as e:
            print(f"âœ— Failed to register: {e}")
            return False

    async def sync_data(self, courses: list, schedules: list, settings: dict):
        """åŒæ­¥æ•°æ®åˆ° Management-Server"""
        import aiohttp

        try:
            async with aiohttp.ClientSession() as session:
                data = {
                    "client_uuid": self.client_uuid,
                    "courses": courses,
                    "schedules": schedules,
                    "settings": settings,
                    "timestamp": datetime.utcnow().isoformat()
                }

                async with session.post(
                    f"{self.base_url}/api/sync",
                    json=data
                ) as resp:
                    if resp.status == 200:
                        print(f"âœ“ Data synced successfully")
                        return True
                    else:
                        print(f"âœ— Sync failed: {resp.status}")
                        return False

        except Exception as e:
            print(f"âœ— Sync error: {e}")
            return False

    async def start_periodic_sync(self, interval: int, get_data_func: Callable):
        """å¯åŠ¨å®šæœŸåŒæ­¥"""
        while True:
            await asyncio.sleep(interval)

            # è·å–å½“å‰æ•°æ®
            data = await get_data_func()
            await self.sync_data(
                data.get("courses", []),
                data.get("schedules", []),
                data.get("settings", {})
            )

    async def connect_websocket(self, on_command: Callable):
        """è¿æ¥ WebSocket ä»¥æ¥æ”¶å®æ—¶æ§åˆ¶"""
        self.ws_connection = LMSConnection(
            self.ws_url,
            self.client_uuid,
            on_command
        )
        await self.ws_connection.connect()


class ConnectionManager:
    """ç»Ÿä¸€è¿æ¥ç®¡ç†å™¨"""

    def __init__(self, settings_manager):
        self.settings = settings_manager
        self.lms_conn: Optional[LMSConnection] = None
        self.mgmt_conn: Optional[ManagementServerConnection] = None
        self.client_uuid = self._get_client_uuid()

    def _get_client_uuid(self) -> str:
        """è·å–å®¢æˆ·ç«¯ UUID"""
        import uuid
        # ä»é…ç½®è¯»å–æˆ–ç”Ÿæˆæ–°çš„
        client_uuid = self.settings.get_setting("client_uuid")
        if not client_uuid:
            client_uuid = str(uuid.uuid4())
            self.settings.update_setting("client_uuid", client_uuid)
        return client_uuid

    async def initialize(self, command_handler: Callable):
        """åˆå§‹åŒ–æ‰€æœ‰è¿æ¥"""
        mode = self.settings.get_setting("dual_connection_mode")

        if mode in ["lms_only", "both"]:
            await self._init_lms_connection(command_handler)

        if mode in ["management_only", "both"]:
            await self._init_management_connection(command_handler)

    async def _init_lms_connection(self, command_handler: Callable):
        """åˆå§‹åŒ– LMS è¿æ¥"""
        if self.settings.get_setting("lms_enabled") == "true":
            lms_url = self.settings.get_setting("lms_url")
            self.lms_conn = LMSConnection(lms_url, self.client_uuid, command_handler)
            await self.lms_conn.connect()

    async def _init_management_connection(self, command_handler: Callable):
        """åˆå§‹åŒ– Management-Server è¿æ¥"""
        if self.settings.get_setting("management_server_enabled") == "true":
            base_url = self.settings.get_setting("management_server_url")
            ws_url = self.settings.get_setting("management_ws_url")

            self.mgmt_conn = ManagementServerConnection(
                base_url,
                ws_url,
                self.client_uuid
            )

            # æ³¨å†Œ
            await self.mgmt_conn.register()

            # è¿æ¥ WebSocket
            await self.mgmt_conn.connect_websocket(command_handler)

            # å¯åŠ¨å®šæœŸåŒæ­¥
            sync_interval = int(self.settings.get_setting("sync_interval"))
            asyncio.create_task(
                self.mgmt_conn.start_periodic_sync(
                    sync_interval,
                    self._get_sync_data
                )
            )

    async def _get_sync_data(self) -> dict:
        """è·å–éœ€è¦åŒæ­¥çš„æ•°æ®"""
        # è¿™é‡Œè°ƒç”¨ schedule_manager å’Œ settings_manager è·å–æ•°æ®
        # ç®€åŒ–ç¤ºä¾‹
        return {
            "courses": [],
            "schedules": [],
            "settings": {}
        }

    async def close(self):
        """å…³é—­æ‰€æœ‰è¿æ¥"""
        if self.lms_conn:
            await self.lms_conn.close()
        # Management-Server è¿æ¥ä¹Ÿéœ€è¦æ¸…ç†
```

**é›†æˆåˆ°ä¸»åº”ç”¨**

```python
# src-tauri/python/tauri_app/__init__.py

from .connection_manager import ConnectionManager

async def command_handler(command: str, params: dict):
    """å¤„ç†æ¥è‡ªç®¡ç†æœåŠ¡å™¨çš„å‘½ä»¤"""
    if command == "update_setting":
        key = params.get("key")
        value = params.get("value")
        settings_manager.update_setting(key, value)
        return {"message": "Setting updated"}

    elif command == "start_cctv_recording":
        camera_id = params.get("camera_id")
        # è°ƒç”¨ CCTV ç®¡ç†å™¨
        return {"message": f"Recording started for {camera_id}"}

    # ... å…¶ä»–å‘½ä»¤ ...

    return {"error": "Unknown command"}

async def main(app: tauri.App):
    """åº”ç”¨ä¸»å…¥å£"""
    global settings_manager, schedule_manager

    # ... åˆå§‹åŒ–ç°æœ‰ç»„ä»¶ ...

    # åˆå§‹åŒ–è¿æ¥ç®¡ç†å™¨
    global connection_manager
    connection_manager = ConnectionManager(settings_manager)
    await connection_manager.initialize(command_handler)

    # ... å…¶ä½™åˆå§‹åŒ– ...
```

## ğŸ“‹ å®æ–½è®¡åˆ’

### é˜¶æ®µ 1: LMS é‡å‘½åå’ŒåŸºç¡€æ”¹è¿› (1-2å¤©)

1. **é‡å‘½åç›®å½•**
   ```bash
   cd classtop
   git mv admin-server lms
   ```

2. **æ·»åŠ æ•°æ®åº“å±‚**
   - åˆ›å»º `lms/db.py`
   - å®ç°å®¢æˆ·ç«¯æ³¨å†Œã€å‘½ä»¤æ—¥å¿—ã€CCTV äº‹ä»¶è®°å½•

3. **æ·»åŠ  Management-Server å®¢æˆ·ç«¯**
   - åˆ›å»º `lms/management_client.py`
   - å®ç°æ³¨å†Œã€å¿ƒè·³é€»è¾‘

4. **æ›´æ–°ä¸»ç¨‹åº**
   - ä¿®æ”¹ `lms/main.py` é›†æˆæ–°åŠŸèƒ½
   - æ·»åŠ å¯åŠ¨/å…³é—­é’©å­

### é˜¶æ®µ 2: Management-Server åŠŸèƒ½æ‰©å±• (2-3å¤©)

1. **æ•°æ®åº“è¿ç§»**
   - åˆ›å»º `migrations/003_add_lms_support.sql`
   - åˆ›å»º `migrations/004_add_cctv_support.sql`
   - è¿è¡Œè¿ç§»

2. **å®ç° LMS ç®¡ç† API**
   - åˆ›å»º `src/handlers/lms.rs`
   - å®ç°æ³¨å†Œã€å¿ƒè·³ã€åˆ—è¡¨ã€åˆ é™¤ç­‰æ¥å£
   - æ·»åŠ åˆ° Repository

3. **å®ç° WebSocket å®æ—¶æ§åˆ¶**
   - åˆ›å»º `src/handlers/websocket.rs`
   - å®ç° WebSocket Actor å’Œè¿æ¥ç®¡ç†å™¨
   - æ·»åŠ å‘½ä»¤è·¯ç”±

4. **å®ç° CCTV ç®¡ç†**
   - æ·»åŠ  CCTV æ•°æ®æ¨¡å‹
   - å®ç° CCTV é…ç½® CRUD
   - æ·»åŠ äº‹ä»¶è®°å½•

### é˜¶æ®µ 3: å®¢æˆ·ç«¯åŒè¿æ¥æ”¯æŒ (2-3å¤©)

1. **æ·»åŠ è¿æ¥é…ç½®**
   - æ›´æ–° `settings_manager.py` é»˜è®¤é…ç½®
   - æ·»åŠ  LMS å’Œ Management-Server é…ç½®é¡¹

2. **å®ç°è¿æ¥ç®¡ç†å™¨**
   - åˆ›å»º `connection_manager.py`
   - å®ç° LMS WebSocket è¿æ¥
   - å®ç° Management-Server HTTP + WS è¿æ¥
   - å®ç°è‡ªåŠ¨é‡è¿é€»è¾‘

3. **å®ç°å‘½ä»¤å¤„ç†å™¨**
   - åˆ›å»ºç»Ÿä¸€çš„å‘½ä»¤å¤„ç†æ¥å£
   - æ”¯æŒè®¾ç½®ä¿®æ”¹ã€CCTV æ§åˆ¶ç­‰å‘½ä»¤

4. **é›†æˆåˆ°ä¸»åº”ç”¨**
   - ä¿®æ”¹ `__init__.py` å¯åŠ¨æµç¨‹
   - æµ‹è¯•åŒè¿æ¥æ¨¡å¼

### é˜¶æ®µ 4: å‰ç«¯ UI æ›´æ–° (2-3å¤©)

1. **Management-Server å‰ç«¯**
   - æ·»åŠ  LMS å®ä¾‹ç›‘æ§é¡µé¢
   - æ˜¾ç¤º LMS åˆ—è¡¨ã€çŠ¶æ€ã€å®¢æˆ·ç«¯æ•°é‡
   - å®ç°å®æ—¶æ§åˆ¶é¢æ¿
   - æ·»åŠ  CCTV ç®¡ç†ç•Œé¢

2. **LMS ç®¡ç†é¡µé¢**
   - æ˜¾ç¤ºè¿æ¥çš„å®¢æˆ·ç«¯åˆ—è¡¨
   - å®æ—¶çŠ¶æ€ç›‘æ§
   - å‘½ä»¤æ‰§è¡Œå†å²

### é˜¶æ®µ 5: æµ‹è¯•å’Œæ–‡æ¡£ (1-2å¤©)

1. **é›†æˆæµ‹è¯•**
   - æµ‹è¯• LMS åˆ° Management-Server æ³¨å†Œ
   - æµ‹è¯•å®¢æˆ·ç«¯åŒè¿æ¥
   - æµ‹è¯•å®æ—¶æ§åˆ¶åŠŸèƒ½
   - æµ‹è¯•æ•°æ®åŒæ­¥

2. **æ€§èƒ½æµ‹è¯•**
   - æµ‹è¯•å¤§é‡å®¢æˆ·ç«¯è¿æ¥
   - æµ‹è¯• WebSocket å»¶è¿Ÿ
   - æµ‹è¯•æ•°æ®åŒæ­¥æ€§èƒ½

3. **æ–‡æ¡£æ›´æ–°**
   - æ›´æ–° README
   - åˆ›å»ºéƒ¨ç½²æŒ‡å—
   - åˆ›å»ºè¿ç§»æŒ‡å—

## ğŸš€ éƒ¨ç½²æŒ‡å—

### LMS éƒ¨ç½²

```bash
# 1. é‡å‘½åå¹¶è¿›å…¥ç›®å½•
cd classtop/lms

# 2. å®‰è£…ä¾èµ–
pip install -r requirements.txt

# 3. é…ç½®ç¯å¢ƒå˜é‡
export MANAGEMENT_SERVER_URL=http://your-management-server:8765

# 4. å¯åŠ¨ LMS
python main.py
```

### Management-Server éƒ¨ç½²

```bash
# 1. è¿›å…¥ç›®å½•
cd Classtop-Management-Server

# 2. è¿è¡Œæ•°æ®åº“è¿ç§»
psql -U postgres -d classtop_management < migrations/003_add_lms_support.sql
psql -U postgres -d classtop_management < migrations/004_add_cctv_support.sql

# 3. æ„å»º
cargo build --release

# 4. å¯åŠ¨
./target/release/classtop-management-server
```

### å®¢æˆ·ç«¯é…ç½®

```python
# åœ¨å®¢æˆ·ç«¯è®¾ç½®ç•Œé¢æˆ–é…ç½®æ–‡ä»¶ä¸­è®¾ç½®

# å¯ç”¨åŒè¿æ¥æ¨¡å¼
dual_connection_mode = "both"

# LMS é…ç½®
lms_enabled = "true"
lms_url = "ws://your-lms:8000/ws"

# Management-Server é…ç½®
management_server_enabled = "true"
management_server_url = "http://your-management-server:8765"
management_ws_url = "ws://your-management-server:8765/ws"
sync_interval = "300"  # 5åˆ†é’Ÿ
```

## ğŸ“Š æ¶æ„ä¼˜åŠ¿

### çµæ´»éƒ¨ç½²

1. **å°è§„æ¨¡åœºæ™¯**ï¼šä»…ä½¿ç”¨ LMS
   - å•ä¸ªæœºæˆ¿/æ•™å®¤
   - å®æ—¶æ§åˆ¶éœ€æ±‚
   - æ— éœ€ä¸­å¤®æœåŠ¡å™¨

2. **ä¸­ç­‰è§„æ¨¡åœºæ™¯**ï¼šLMS + Management-Server
   - å¤šä¸ªæœºæˆ¿ç»Ÿä¸€ç®¡ç†
   - éœ€è¦æ•°æ®åˆ†æ
   - ä¿ç•™å®æ—¶æ§åˆ¶èƒ½åŠ›

3. **å¤§è§„æ¨¡åœºæ™¯**ï¼šå¤šä¸ª LMS + Management-Server
   - å¤šæ ¡åŒºéƒ¨ç½²
   - åˆ†å±‚ç®¡ç†
   - ç»Ÿä¸€æ•°æ®ä¸­å¿ƒ

### æ€§èƒ½ä¼˜åŠ¿

- **å®æ—¶æ§åˆ¶**ï¼šLMS WebSocket æä¾›æ¯«ç§’çº§å»¶è¿Ÿ
- **æ‰¹é‡åŒæ­¥**ï¼šManagement-Server HTTP æ‰¹é‡å¤„ç†
- **è´Ÿè½½åˆ†æ‹…**ï¼šLMS åˆ†æ‹…å®æ—¶é€šä¿¡è´Ÿè½½
- **å¯æ‰©å±•æ€§**ï¼šå¯æ¨ªå‘æ‰©å±• LMS æ•°é‡

### å¯é æ€§ä¼˜åŠ¿

- **ç¦»çº¿è¿è¡Œ**ï¼šLMS å¯ç‹¬ç«‹è¿è¡Œ
- **æ•…éšœéš”ç¦»**ï¼šå•ä¸ª LMS æ•…éšœä¸å½±å“å…¶ä»–
- **è‡ªåŠ¨é‡è¿**ï¼šå®¢æˆ·ç«¯è‡ªåŠ¨é‡è¿æœºåˆ¶
- **æ•°æ®å¤‡ä»½**ï¼šManagement-Server é›†ä¸­å¤‡ä»½

## ğŸ”§ æœªæ¥æ‰©å±•

1. **LMS é›†ç¾¤**ï¼šå¤šä¸ª LMS å®ä¾‹è´Ÿè½½å‡è¡¡
2. **æ•°æ®åŠ å¯†**ï¼šæ•æ„Ÿæ•°æ®ä¼ è¾“åŠ å¯†
3. **æƒé™ç®¡ç†**ï¼šç»†ç²’åº¦æƒé™æ§åˆ¶
4. **ç›‘æ§å‘Šè­¦**ï¼šç³»ç»Ÿç›‘æ§å’Œå‘Šè­¦é€šçŸ¥
5. **ç§»åŠ¨ç«¯**ï¼šç§»åŠ¨ç«¯ç®¡ç†åº”ç”¨

---

**å®Œæˆæ—¶é—´ä¼°ç®—**: 8-12 ä¸ªå·¥ä½œæ—¥
**ä¼˜å…ˆçº§**: é«˜
**ç»´æŠ¤è€…**: Zixiao System Team